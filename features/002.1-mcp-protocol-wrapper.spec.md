# Feature 002.1: MCP Protocol Wrapper for Multi-Service Support

**Feature ID**: 002.1-mcp-protocol-wrapper  
**Status**: Specification Complete  
**Created**: 2026-02-10  
**Owner**: Development Team  
**Parent Feature**: 002-eventlog-mcp (93% complete)  
**Depends On**: Feature 001 (MCP Host Bootstrap)

---

## Overview

Feature 002.1 wraps existing GraphQL-based system resource services (starting with EventLog from Feature 002) with full MCP (Model Context Protocol) compliance. This creates a proper MCP server that can be used by Claude and other LLM clients via stdio communication.

The wrapper implements a multi-service architecture designed to support present and future services (EventLog, FileSearch, Registry, etc.) through a single stdio-based MCP server process. Rather than exposing GraphQL directly, services are exposed as MCP tools with proper schema definitions, error handling, and resource discovery.

**Key Innovation**: This feature bridges the gap between Feature 002's GraphQL implementation and the MCP protocol requirement, enabling proper LLM integration while maintaining the ability to add new services without protocol rewrites.

---

## Goals

1. **MCP Protocol Compliance**: Implement full MCP protocol (version 2024-11-05 or latest) with proper initialization, capabilities advertisement, and tool/resource management
2. **Multi-Service Architecture**: Design extensible service registry allowing future services (FileSearch, Registry, etc.) to be added without modifying core MCP logic
3. **Stdio Communication**: Implement JSON-RPC based stdio communication for proper MCP client integration
4. **Service Tool Exposure**: Convert service capabilities into MCP tool definitions with proper schema, inputs, and result types
5. **Proper Error Handling**: Implement MCP error codes and handling patterns for all failure scenarios
6. **Production Quality**: Comprehensive logging, validation, and test coverage (>80%) for MCP protocol handling
7. **Future-Proofing**: Architecture designed for multiple services, resources, and advanced features (permissions, buffering)

---

## User Stories

### Story 1: Claude Integration via Stdio
**As a** Claude user  
**I want to** invoke system resource queries via MCP tools  
**So that** Claude can understand what's happening on my Windows system

### Story 2: Tool Discovery
**As a** Claude client  
**I want to** discover available tools and their parameters  
**So that** I can construct proper requests without documentation

### Story 3: Multi-Service Support
**As a** developer  
**I want to** add new system resource services (FileSearch, Registry, etc.)  
**So that** I can expand system capabilities without reimplementing MCP protocol

### Story 4: Error Handling
**As a** Claude user  
**I want to** receive clear error messages when operations fail  
**So that** I can understand why a query didn't work

### Story 5: Service Configuration
**As a** system administrator  
**I want to** enable/disable individual services  
**So that** I can control which system resources are exposed

### Story 6: Audit Trail
**As a** security-conscious user  
**I want to** see what operations were performed via MCP  
**So that** I can audit system access

---

## Functional Requirements

### FR-1: MCP Protocol Implementation
- Implement MCP protocol version 2024-11-05 (or latest stable)
- Support JSON-RPC 2.0 message format over stdio
- Handle proper initialization sequence:
  - `initialize` request with capabilities
  - `initialized` notification
  - Protocol negotiation
- Support all required message types:
  - `Request` / `Response`
  - `Notification`
  - Proper error responses with MCP error codes

### FR-2: Initialization & Capabilities
- Advertise MCP server capabilities in `initialize` response:
  - `tools` (available tools for each service)
  - `resources` (future: for resource management)
  - `prompts` (future: for prompt management)
- Provide server metadata:
  - `name`: "SysMCP Multi-Service Server"
  - `version`: Matches project version
  - Protocol version
- Support protocol negotiation for version compatibility

### FR-3: Tool Definitions & Discovery
- Implement `tools/list` endpoint to return all available tools
- Each service defines its tools with complete schema:
  - Tool name (e.g., `eventlog_query`, `filesystem_search`)
  - Human-readable description
  - Input schema (JSON Schema format)
  - Return type documentation
- Example EventLog tools:
  - `eventlog_query`: Query events with filters (time range, level, source, message)
  - `eventlog_list_logs`: List available event log names
  - `eventlog_export`: Export events to file (future)
- Tools are namespaced by service for clarity

### FR-4: Tool Execution
- Implement `tools/call` endpoint to execute requested tools
- Validate tool call request:
  - Tool exists and is available
  - Input parameters match schema
  - Required parameters present
- Route tool call to appropriate service
- Handle execution result:
  - Return successful result with proper format
  - Return MCP error on failure with error code
  - Sanitize error messages (no sensitive details to client)
- Support tool arguments as JSON object matching declared schema

### FR-5: Service Registry & Routing
- Implement ServiceRegistry to manage service instances:
  - Register service with unique identifier
  - List available services
  - Get service by name
  - Validate service is enabled before routing requests
- Service interface:
  ```
  interface IService {
    id: string;
    name: string;
    version: string;
    enabled: boolean;
    getTools(): ToolDefinition[];
    executeTool(toolName: string, args: unknown): Promise<ToolResult>;
  }
  ```
- Support dynamic service registration for future features

### FR-6: Multi-Service Tool Namespace
- Implement tool naming convention: `{serviceId}_{operationName}`
  - Example: `eventlog_query`, `filesystem_search`, `registry_read`
- Each service namespace isolated from others
- Tool discovery returns all tools from all enabled services
- Service manager routes calls to correct service based on tool name prefix

### FR-7: Error Handling & Validation
- Validate all incoming MCP requests:
  - Valid JSON-RPC format
  - Required fields present
  - Message ID present (for request/response tracking)
- Input validation:
  - Tool parameters match declared schema
  - Type checking for parameters
  - Range validation where applicable
- Error responses use MCP error codes:
  - `-32600`: Invalid Request
  - `-32601`: Method not found
  - `-32602`: Invalid params
  - `-32603`: Internal error
  - `-32700`: Parse error
- Error messages:
  - Generic message to client (no system details)
  - Detailed logging internally
  - Clear problem description for debugging

### FR-8: Logging & Observability
- Log all MCP operations:
  - Initialization events
  - Tool discovery requests
  - Tool call requests (parameters, not sensitive data)
  - Tool results (success/failure, execution time)
  - Errors with full stack traces (internal logs only)
- Include contextual information:
  - Request ID (for tracing)
  - Timestamp
  - Service and tool name
  - Execution time
  - Caller information (if available)
- Support configurable log levels (DEBUG, INFO, WARN, ERROR)

### FR-9: Input/Output Validation
- Validate stdio input:
  - Line-by-line JSON-RPC parsing
  - Handle invalid JSON gracefully
  - Don't crash on malformed input
- Output validation:
  - All MCP responses are valid JSON-RPC format
  - Response headers complete (jsonrpc, result/error, id)
  - Proper encoding (UTF-8)
  - Line-terminated output

### FR-10: Service Configuration State
- Support enabling/disabling services:
  - **Hardcoded for MVP**: All services enabled by default
  - **Design for Future**: Configuration system for disabling services
  - Disabled services not listed in tools/list
  - Tool calls to disabled services return error
  - Configuration can change at runtime (future)

### FR-11: Type Safety & Schema
- Define TypeScript interfaces for:
  - MCP protocol messages
  - Service interfaces
  - Tool definitions
  - Request/response types
- Use JSON Schema for tool input/output validation
- Runtime schema validation
- Type-safe tool execution

---

## Non-Functional Requirements

### NFR-1: Protocol Compliance
- Full compliance with MCP specification (2024-11-05 or latest)
- Proper JSON-RPC 2.0 implementation
- Handle all required protocol states and transitions
- Support future protocol extensions without breaking changes

### NFR-2: Performance
- Tool call latency:
  - Tool execution < 100ms for typical queries (EventLog)
  - Tool discovery (list) < 50ms
  - Total response time < 200ms including I/O
- Stdio throughput: Support concurrent tool calls without blocking
- Memory usage: < 100MB for service hosting + tool metadata

### NFR-3: Reliability
- Handle all error conditions gracefully
- Never crash or close stdio unexpectedly
- Recover from transient failures (service unavailable)
- Maintain message sequencing for request/response matching

### NFR-4: Extensibility
- Adding new service requires:
  - Implementing IService interface
  - Calling registry.register(service)
  - No MCP protocol modifications
- Support service dependencies (service A depends on service B)
- Support runtime service registration (future)

### NFR-5: Security
- All inputs validated before use
- No command injection through tool parameters
- Service isolation (one service failure doesn't crash others)
- Audit trail of all tool executions
- PII already handled by EventLog service (anonymization)

### NFR-6: Testability
- Minimum 80% code coverage
- All components unit testable in isolation
- Integration tests for MCP protocol handling
- Mock services for testing without real system resources
- Error scenario testing

### NFR-7: Maintainability
- Code organized into logical modules:
  - MCP protocol handler
  - Service registry and routing
  - Tool definitions and execution
  - Error handling and validation
- Each module < 300 lines
- Clear separation of concerns
- Comprehensive inline documentation

---

## Architecture

### System Architecture Diagram

```
┌─────────────────────────────────────────────────────────────────┐
│                        MCP Client (Claude)                      │
│                      (communicates via stdio)                   │
└────────────────────────────┬────────────────────────────────────┘
                             │
                   JSON-RPC over stdio
                             │
┌────────────────────────────▼────────────────────────────────────┐
│              SysMCP MCP Server (Node.js process)                │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │         MCP Protocol Handler (stdio)                    │  │
│  │  • JSON-RPC message parsing and formatting              │  │
│  │  • Protocol initialization & capabilities               │  │
│  │  • Message routing to appropriate handlers              │  │
│  │  • Error handling and response generation               │  │
│  └────────┬────────────────────────────────────────────────┘  │
│           │                                                    │
│  ┌────────▼────────────────────────────────────────────────┐  │
│  │     Tool Registry & Handler                             │  │
│  │  • tools/list: Returns all available tools              │  │
│  │  • tools/call: Executes requested tool                  │  │
│  │  • Tool discovery and validation                        │  │
│  │  • Input/output schema validation                       │  │
│  └────────┬────────────────────────────────────────────────┘  │
│           │                                                    │
│  ┌────────▼────────────────────────────────────────────────┐  │
│  │     Service Manager & Routing                           │  │
│  │  • Service registry (register, list, get)               │  │
│  │  • Route {service}_{operation} to correct service      │  │
│  │  • Service lifecycle management                         │  │
│  │  • Configuration state (enabled/disabled)               │  │
│  └────────┬────────────────────────────────────────────────┘  │
│           │                                                    │
│  ┌────────▼────────────────────────────────────────────────┐  │
│  │              Service Implementations                    │  │
│  │  ┌──────────────────────────────────────────────────┐  │  │
│  │  │  EventLog Service                                │  │  │
│  │  │  • eventlog_query                                │  │  │
│  │  │  • eventlog_list_logs                            │  │  │
│  │  │  (wraps existing Feature 002 GraphQL API)        │  │  │
│  │  └──────────────────────────────────────────────────┘  │  │
│  │  ┌──────────────────────────────────────────────────┐  │  │
│  │  │  FileSearch Service (future)                      │  │  │
│  │  │  • filesystem_search                              │  │  │
│  │  │  • filesystem_list                                │  │  │
│  │  └──────────────────────────────────────────────────┘  │  │
│  │  ┌──────────────────────────────────────────────────┐  │  │
│  │  │  Registry Service (future)                        │  │  │
│  │  │  • registry_read                                  │  │  │
│  │  │  • registry_list                                  │  │  │
│  │  └──────────────────────────────────────────────────┘  │  │
│  └─────────────────────────────────────────────────────────┘  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                             │
                System Resources (EventLog, Filesystem, Registry)
```

### Data Flow: Tool Execution

```
1. MCP Client sends tool/call request (JSON-RPC):
   {
     "jsonrpc": "2.0",
     "id": 1,
     "method": "tools/call",
     "params": {
       "name": "eventlog_query",
       "arguments": {
         "logName": "System",
         "limit": 100
       }
     }
   }

2. MCP Protocol Handler:
   ├─ Parse and validate JSON-RPC format
   ├─ Validate method is "tools/call"
   ├─ Extract tool name and arguments
   └─ Route to Tool Handler

3. Tool Handler:
   ├─ Look up tool definition in registry
   ├─ Validate arguments against schema
   ├─ Extract service name from tool name (eventlog_query → eventlog)
   └─ Route to Service Manager

4. Service Manager:
   ├─ Look up service (eventlog)
   ├─ Check if service is enabled
   ├─ Extract operation name (eventlog_query → query)
   └─ Call service.executeTool("query", arguments)

5. EventLog Service:
   ├─ Route to internal tool executor
   ├─ Call existing GraphQL resolver
   ├─ Return result
   └─ Send result back up the chain

6. MCP Protocol Handler:
   ├─ Format result as JSON-RPC response
   ├─ Include execution time metrics
   ├─ Send response to stdout
   └─ Log operation

7. MCP Client receives:
   {
     "jsonrpc": "2.0",
     "id": 1,
     "result": {
       "content": [
         {
           "type": "text",
           "text": "... event log entries ..."
         }
       ]
     }
   }
```

### Module Structure

```
src/
├── mcp/                          # NEW: MCP Protocol Implementation
│   ├── index.ts                  # MCP server entry point
│   ├── protocol-handler.ts        # JSON-RPC/stdio handling
│   ├── message-types.ts           # Protocol message type definitions
│   ├── error-handler.ts           # MCP error codes and handling
│   ├── service-manager.ts         # Service registry and routing
│   ├── tool-registry.ts           # Tool definitions and validation
│   ├── tool-executor.ts           # Tool execution orchestration
│   ├── schema-validator.ts        # JSON Schema validation
│   └── __tests__/
│       ├── protocol-handler.test.ts
│       ├── service-manager.test.ts
│       ├── tool-executor.test.ts
│       ├── integration.test.ts
│       └── error-handling.test.ts
│
├── services/
│   ├── eventlog/                 # EXISTING: Feature 002
│   │   └── mcp-service.ts         # NEW: MCP wrapper for EventLog
│   └── shared/                   # NEW: Shared service interfaces
│       └── service-interface.ts   # IService interface definition
│
├── index.ts                      # Updated: Switch based on mode
└── server.ts                     # EXISTING: GraphQL server
```

---

## Design Considerations

### 1. Multi-Service Architecture

**Requirement**: Each service registers tools under its own namespace

**Approach**:
- ServiceRegistry maintains map of service ID → service instance
- Tool names follow pattern: `{serviceId}_{operationName}`
- ServiceManager extracts service ID from tool name and routes
- Example:
  - EventLog service registers tools: `eventlog_query`, `eventlog_list_logs`
  - FileSearch service (future) registers: `filesystem_search`, `filesystem_list`
  - Registry service (future) registers: `registry_read`, `registry_list_keys`

**Benefits**:
- No tool name conflicts between services
- Clear tool discovery (users see service+operation)
- Extensible (add new service = register new tools)
- Service isolation (one service failure doesn't affect others)

### 2. MCP Protocol Compliance

**Requirement**: Full compliance with MCP specification

**Approach**:
- Implement JSON-RPC 2.0 protocol handler
- Support proper initialization sequence
- Use MCP error codes for all error responses
- Validate all messages against protocol spec
- Support protocol versioning for future compatibility

**Implementation Details**:
- Each message includes jsonrpc, id (for request/response matching), method/result/error
- Notifications have no id field
- Error responses include code, message, and optional data field
- Protocol version advertised during initialization

### 3. Service Integration Pattern

**Requirement**: Minimize changes to existing services

**Approach**:
- Create IService interface that services implement
- EventLog service creates MCPService wrapper around existing GraphQL provider
- MCPService handles tool definition and execution translation
- GraphQL logic unchanged; MCP layer adds protocol support

**Example (EventLog)**:
```typescript
class EventLogMCPService implements IService {
  executeTool(toolName: string, args: unknown): Promise<ToolResult> {
    if (toolName === "eventlog_query") {
      // Call existing GraphQL resolver with args
      // Format result as MCP ToolResult
    }
  }
}
```

### 4. Input Validation & Error Handling

**Requirement**: Robust validation and clear error messages

**Approach**:
- Two-level validation:
  - MCP protocol level (valid JSON-RPC format)
  - Tool parameter level (valid schema match)
- JSON Schema validation for tool inputs
- Error codes indicate problem type
- Generic error messages to client, detailed logs internally

### 5. Future Extensibility

**Considerations**:
- Service dependencies (FileSearch might depend on FS access validation)
- Permissions model (different services, different permission levels)
- Write operation buffering (future services will need approval flow)
- Resource definitions (for file browsing, registry browsing, etc.)
- Prompt definitions (for guiding LLM interaction)

**Design Accommodates**:
- IService interface allows for service-specific config
- ServiceManager can be extended for permission/buffering logic
- Tool schema can express read vs. write vs. dangerous operations
- Resources and prompts can be added to protocol handler

---

## Constraints & Limitations

### C-1: Stdio Communication
- Single stdio stream for both requests and responses
- Messages must be properly framed (line-terminated JSON)
- No support for binary protocols (unlike alternative transports)
- **Mitigation**: Line-by-line JSON parsing with proper error recovery

### C-2: Single Process
- All services run in one Node.js process
- Resource limits on total process memory (~500MB typical)
- One crash crashes all services
- **Mitigation**: Service isolation, error recovery, monitoring

### C-3: Feature 002 Integration
- EventLog service exists as GraphQL API
- MCP wrapper must translate between protocols
- Any changes to GraphQL schema require MCP tool definition updates
- **Mitigation**: Update tools when schema changes, test integration thoroughly

### C-4: Protocol Versioning
- MCP specification may evolve
- Current implementation targets 2024-11-05
- Future clients may require updated server
- **Mitigation**: Version negotiation in initialization

---

## Out of Scope

The following items are explicitly out of scope for Feature 002.1:

- **Resources**: Resource management (file browsing, etc.) - future feature
- **Prompts**: Prompt definitions - future feature
- **Complex Permissions**: Advanced permission model (Feature 4+)
- **Write Operation Buffering**: Approval workflows - Feature 3+
- **Multi-Transport**: HTTP, WebSocket, other transports - future features
- **Clustering**: Multi-process or distributed deployment
- **Advanced Caching**: Service-level caching strategies
- **GraphQL to MCP Mapping**: Only EventLog for this feature; FileSearch uses its own tools

---

## Success Criteria

- [ ] **SC-1: MCP Protocol Implemented**: Full protocol handler with initialization, tools/list, tools/call
- [ ] **SC-2: Service Registry Works**: Services can be registered, discovered, routed to correctly
- [ ] **SC-3: EventLog Integration**: Feature 002 GraphQL wrapped as MCP service with proper tools
- [ ] **SC-4: Tool Discovery Functional**: tools/list returns all tools with proper schema
- [ ] **SC-5: Tool Execution Works**: tools/call executes tools, returns results, handles errors
- [ ] **SC-6: Error Handling Proper**: All errors return MCP error codes, no sensitive info leaked
- [ ] **SC-7: Validation Complete**: Input validation at protocol and tool levels
- [ ] **SC-8: Logging Comprehensive**: All operations logged with proper context
- [ ] **SC-9: Type Safety**: 100% TypeScript strict mode
- [ ] **SC-10: Test Coverage >80%**: Unit, integration, and error scenario tests
- [ ] **SC-11: Documentation Complete**: Protocol documentation, tool definitions, integration guide
- [ ] **SC-12: Extensibility Verified**: FileSearch service can be added without MCP changes
- [ ] **SC-13: Claude Integration**: Works with Claude via stdio

---

## Questions for Design Review

1. **Protocol Version**: Should we start with MCP 2024-11-05, or check for latest version?
2. **Tool Naming Convention**: Is `{service}_{operation}` the best pattern, or prefer different naming?
3. **Error Detail Level**: How much implementation detail should error messages include?
4. **Service Configuration**: Should service enable/disable be configurable at runtime (MVP) or hardcoded?
5. **Tool Categorization**: Should tools be grouped by category/namespace beyond service level?
6. **Resource Support**: Should Feature 2.1 include basic resource support, or save for later?
7. **Authentication**: Should MCP protocol include authentication/authorization at transport level?
8. **Telemetry**: Should tool execution metrics be included in every response or on-demand?

---

## Next Steps

1. **Specification Review**: Confirm this specification with stakeholders
2. **Technical Planning**: Create detailed technical plan (tools, module structure, dependencies)
3. **Task Breakdown**: Break into implementation tasks with clear acceptance criteria
4. **Implementation**: Build MCP protocol layer and service integration
5. **Integration Testing**: Test with Claude and other MCP clients
6. **Documentation**: Create integration guide and tool documentation

---

## Document Metadata

- **Specification Version**: 1.0
- **Created**: 2026-02-10
- **Last Updated**: 2026-02-10
- **Status**: Draft - Ready for Review
- **Related Documents**:
  - `/features/002-eventlog-mcp.spec.md` - EventLog specification (Feature 2)
  - `/features/002-eventlog-mcp.plan.md` - EventLog technical plan
  - `/features/001-mcp-host-bootstrap.spec.md` - MCP Host specification
  - `.github/copilot-instructions.md` - Architecture guidelines
- **Dependencies**: Feature 001 (complete), Feature 002 (93% complete)
- **Stakeholders**: Development Team, Project Lead, Claude Integration Team

