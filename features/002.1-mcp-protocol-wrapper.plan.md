# Technical Implementation Plan: MCP Protocol Wrapper for Multi-Service Support

**Feature Number**: 002.1  
**Feature Title**: MCP Protocol Wrapper for Multi-Service Support  
**Document Version**: 1.0  
**Created**: 2026-02-10  
**Status**: Ready for Implementation  

---

## Executive Summary

This document provides the detailed technical implementation plan for Feature 002.1, which wraps existing GraphQL-based system resource services with full MCP (Model Context Protocol) compliance.

Building on Feature 002's EventLog GraphQL API (93% complete) and Feature 001's MCP Host infrastructure, this feature implements:

1. **JSON-RPC 2.0 Protocol Handler** - Proper stdio-based MCP communication
2. **Service Registry & Routing** - Multi-service architecture for present and future services
3. **Tool Definitions & Execution** - MCP tool discovery and execution with schema validation
4. **Error Handling & Validation** - MCP-compliant error responses with proper error codes
5. **Comprehensive Logging** - Full audit trail and debugging support

The implementation is designed to support multiple services (EventLog first, FileSearch and Registry in future) without protocol rewrites, with >80% test coverage and production-ready error handling.

---

## Architecture Deep Dive

### 1. MCP Protocol Handler (Core Component)

**Purpose**: Manage stdio communication and JSON-RPC protocol

**Responsibilities**:
- Line-by-line JSON parsing from stdin
- Protocol message routing (initialize, tools/list, tools/call, etc.)
- Response formatting and output to stdout
- Protocol state management
- Error handling and response generation

**File**: `src/mcp/protocol-handler.ts`

**Key Classes**:
```typescript
class MCPProtocolHandler {
  // Initialize handler with stdio streams
  constructor(stdin: NodeJS.ReadableStream, stdout: NodeJS.WritableStream)

  // Start listening for messages
  start(): Promise<void>

  // Register handler for specific method
  onMethod(method: string, handler: RequestHandler): void

  // Send response to client
  sendResponse(id: string | number, result: unknown): void

  // Send error response to client
  sendError(id: string | number, error: MCPError): void

  // Send notification to client
  sendNotification(method: string, params: unknown): void

  // Stop handler gracefully
  stop(): Promise<void>
}
```

**Message Types**:
```typescript
interface JSONRPCMessage {
  jsonrpc: "2.0";
  method?: string;
  params?: unknown;
  result?: unknown;
  error?: JSONRPCError;
  id?: string | number;
}

interface JSONRPCError {
  code: number;
  message: string;
  data?: unknown;
}
```

**Error Codes** (JSON-RPC standard + MCP extensions):
```typescript
enum MCPErrorCode {
  ParseError = -32700,
  InvalidRequest = -32600,
  MethodNotFound = -32601,
  InvalidParams = -32602,
  InternalError = -32603,
  // MCP-specific
  ServerError = -32000,
  ToolNotFound = -32001,
  ToolExecutionError = -32002,
}
```

**Implementation Plan**:
1. Parse stdin line-by-line (each message is one line of JSON)
2. Validate JSON format, return ParseError if invalid
3. Route by method name to registered handlers
4. Handle initialization, tools/list, tools/call
5. Format responses as JSON-RPC 2.0
6. Output to stdout with newline terminator
7. Log all operations for debugging

**Test Strategy**:
- Unit tests for JSON parsing (valid, invalid, edge cases)
- Protocol state machine tests (initialization sequence)
- Response formatting tests
- Error scenario tests (parse error, method not found, etc.)
- Integration tests with mock services

### 2. Service Interface & Registry

**Purpose**: Manage service lifecycle and routing

**File**: `src/services/shared/service-interface.ts`

**Interface Definition**:
```typescript
interface ToolDefinition {
  name: string;
  description: string;
  inputSchema: JSONSchema;
  outputType?: string;
}

interface ToolResult {
  content: Array<{
    type: "text" | "image";
    text?: string;
    data?: string;
    mimeType?: string;
  }>;
}

interface IService {
  id: string;
  name: string;
  version: string;
  enabled: boolean;

  // Get available tools for this service
  getTools(): ToolDefinition[];

  // Execute a tool
  executeTool(toolName: string, args: unknown): Promise<ToolResult>;
}
```

**Service Registry** (`src/mcp/service-manager.ts`):
```typescript
class ServiceManager {
  // Register a service
  register(service: IService): void

  // Get service by ID
  getService(id: string): IService | undefined

  // Get all services
  listServices(): IService[]

  // List all tools from all enabled services
  listTools(): ToolDefinition[]

  // Find and execute tool (routes to correct service)
  executeTool(toolName: string, args: unknown): Promise<ToolResult>

  // Enable/disable service
  setServiceEnabled(id: string, enabled: boolean): void
}
```

**Implementation Details**:
- Services stored in Map<id, service>
- Tool lookup by name (maps to service.id_operationName)
- Service routing: split tool name, get service, call executeTool
- Error handling: service not found, disabled service, tool not found
- Logging: all service operations logged with context

**Tool Naming Convention**:
```
eventlog_query          → eventlog service, query operation
eventlog_list_logs      → eventlog service, list_logs operation
filesystem_search       → filesystem service, search operation (future)
registry_read           → registry service, read operation (future)
```

### 3. EventLog MCP Service Wrapper

**Purpose**: Expose Feature 002 EventLog GraphQL as MCP service

**File**: `src/services/eventlog/mcp-service.ts`

**Tool Definitions**:
```typescript
const EVENTLOG_TOOLS: ToolDefinition[] = [
  {
    name: "eventlog_query",
    description: "Query Windows Event Logs with filtering and pagination",
    inputSchema: {
      type: "object",
      properties: {
        logName: { type: "string", description: "Log name (e.g., System, Application)" },
        limit: { type: "integer", minimum: 1, maximum: 1000, default: 100 },
        offset: { type: "integer", minimum: 0, default: 0 },
        minLevel: { type: "string", enum: ["ERROR", "WARNING", "INFO", "VERBOSE", "DEBUG"] },
        source: { type: "string" },
        startTime: { type: "string", format: "date-time" },
        endTime: { type: "string", format: "date-time" },
        messageContains: { type: "string" },
        useCursor: { type: "boolean", default: false }
      },
      required: ["logName"]
    }
  },
  {
    name: "eventlog_list_logs",
    description: "List available Windows Event Log names",
    inputSchema: {
      type: "object",
      properties: {}
    }
  }
];
```

**Implementation**:
```typescript
class EventLogMCPService implements IService {
  id = "eventlog";
  name = "Windows Event Log Service";
  version = "1.0.0";
  enabled = true;

  constructor(private graphqlProvider: EventLogProvider) {}

  getTools(): ToolDefinition[] {
    return EVENTLOG_TOOLS;
  }

  async executeTool(toolName: string, args: unknown): Promise<ToolResult> {
    switch (toolName) {
      case "eventlog_query":
        return this.handleQuery(args);
      case "eventlog_list_logs":
        return this.handleListLogs(args);
      default:
        throw new Error(`Unknown tool: ${toolName}`);
    }
  }

  private async handleQuery(args: unknown): Promise<ToolResult> {
    // Validate arguments against schema
    const validated = validateEventLogQueryArgs(args);
    
    // Call existing GraphQL provider
    const result = await this.graphqlProvider.query({
      logName: validated.logName,
      limit: validated.limit,
      offset: validated.offset,
      // ... other fields
    });

    // Format as MCP ToolResult
    return {
      content: [{
        type: "text",
        text: JSON.stringify(result, null, 2)
      }]
    };
  }

  private async handleListLogs(args: unknown): Promise<ToolResult> {
    const logs = await this.graphqlProvider.listLogs();
    return {
      content: [{
        type: "text",
        text: JSON.stringify(logs, null, 2)
      }]
    };
  }
}
```

**Integration Point**:
- Existing EventLog GraphQL provider wrapped (not modified)
- Arguments translated from MCP format to GraphQL format
- Results formatted as MCP ToolResult (text content)
- All error handling delegated to protocol handler

### 4. Tool Registry & Execution

**Purpose**: Manage tool definitions and execution

**File**: `src/mcp/tool-executor.ts`

**Class Structure**:
```typescript
class ToolExecutor {
  constructor(private serviceManager: ServiceManager) {}

  // Validate tool exists
  validateTool(name: string): boolean

  // Get tool definition
  getTool(name: string): ToolDefinition | undefined

  // List all tools
  listTools(): ToolDefinition[]

  // Execute tool with input validation
  async executeTool(name: string, args: unknown): Promise<ToolResult>
}
```

**Execution Flow**:
1. Receive tool name and arguments from MCP request
2. Look up tool definition
3. Validate arguments against input schema (JSON Schema)
4. Extract service name from tool name
5. Get service from registry
6. Call service.executeTool
7. Format result as MCP ToolResult
8. Return to caller

**Schema Validation** (`src/mcp/schema-validator.ts`):
```typescript
class SchemaValidator {
  // Validate data against JSON Schema
  validate(data: unknown, schema: JSONSchema): ValidationResult

  // Get validation errors
  getErrors(): ValidationError[]
}

interface ValidationError {
  message: string;
  path: string; // e.g., "properties.limit"
  value: unknown;
}
```

**Error Handling**:
- Tool not found → MethodNotFound error
- Invalid arguments → InvalidParams error with error details
- Service not found → InternalError (shouldn't happen)
- Service execution error → ToolExecutionError with error details
- All errors logged internally with full context

### 5. Input Validation & Error Handling

**Purpose**: Comprehensive validation and error reporting

**Files**: 
- `src/mcp/error-handler.ts`
- `src/mcp/schema-validator.ts`

**Error Hierarchy**:
```typescript
class MCPError extends Error {
  constructor(
    public code: number,
    message: string,
    public data?: unknown
  ) {
    super(message);
  }
}

class ToolNotFoundError extends MCPError {
  constructor(toolName: string) {
    super(-32001, `Tool not found: ${toolName}`);
  }
}

class InvalidParamsError extends MCPError {
  constructor(message: string, public validationErrors: ValidationError[]) {
    super(-32602, message);
    this.data = { errors: validationErrors };
  }
}

class ToolExecutionError extends MCPError {
  constructor(message: string, originalError?: Error) {
    super(-32002, message);
    this.data = originalError?.message;
  }
}
```

**Validation Strategy**:
1. **Protocol Level**: Validate JSON-RPC format (jsonrpc, id, method, params)
2. **Method Level**: Validate method exists (initialize, tools/list, tools/call)
3. **Parameters Level**: Validate parameters match method signature
4. **Tool Level**: Validate tool name exists and is enabled
5. **Schema Level**: Validate tool arguments against input schema

**Error Messages**:
- Client: Generic, non-technical message (e.g., "Invalid parameters")
- Internal Log: Full error details, stack trace, validation errors
- Example Error Response:
  ```json
  {
    "jsonrpc": "2.0",
    "id": 1,
    "error": {
      "code": -32602,
      "message": "Invalid parameters",
      "data": {
        "errors": [
          {
            "message": "must be >= 1",
            "path": "properties.limit"
          }
        ]
      }
    }
  }
  ```

### 6. Initialization & Capabilities

**Purpose**: Protocol initialization and capability negotiation

**Implementation** in `protocol-handler.ts`:
```typescript
private handleInitialize(params: InitializeRequest): ServerCapabilities {
  // Validate client params
  const clientInfo = params.clientInfo;
  const protocolVersion = params.protocolVersion;

  // Log initialization
  this.logger.info("Client initialized", { clientInfo, protocolVersion });

  // Return server capabilities
  return {
    serverInfo: {
      name: "SysMCP Multi-Service Server",
      version: "0.1.0"
    },
    protocolVersion: "2024-11-05",
    capabilities: {
      tools: {
        listChanged: false
      },
      resources: {
        subscribe: false
      },
      sampling: {}
    }
  };
}
```

**Capabilities Format**:
```typescript
interface ServerCapabilities {
  serverInfo: {
    name: string;
    version: string;
  };
  protocolVersion: string;
  capabilities: {
    tools: {
      listChanged: boolean; // whether tool list can change at runtime
    };
    resources: {
      subscribe: boolean; // whether resources supported
    };
    sampling: {}; // sampling capabilities (future)
  };
}
```

### 7. Logging & Observability

**Purpose**: Comprehensive operation logging for debugging and audit

**Implementation** in `src/mcp/logger.ts`:
```typescript
class MCPLogger {
  // Log protocol initialization
  logInitialization(clientInfo: unknown, protocolVersion: string): void

  // Log tool discovery
  logToolDiscovery(count: number): void

  // Log tool execution
  logToolExecution(toolName: string, args: unknown, duration: number): void

  // Log errors
  logError(error: Error, context: unknown): void

  // Log validation errors
  logValidationError(toolName: string, errors: ValidationError[]): void
}
```

**Log Format**:
```
[2026-02-10T10:30:45.123Z] [INFO] Initialize: protocol=2024-11-05 client=Claude
[2026-02-10T10:30:46.234Z] [INFO] ListTools: count=2 services=1
[2026-02-10T10:30:47.345Z] [INFO] ToolCall: tool=eventlog_query duration=45ms status=success
[2026-02-10T10:30:48.456Z] [ERROR] ToolExecution: tool=eventlog_query error=InvalidParams
```

**Structured Logging**:
```typescript
logger.info("Tool executed", {
  toolName: "eventlog_query",
  duration: 45,
  success: true,
  resultSize: 1024,
  requestId: "req-123" // for tracing
});
```

---

## Implementation Phases

### Phase 1: MCP Protocol Core (Week 1)
**Goal**: Basic MCP protocol handler with initialization and tool discovery

**Tasks**:
1. Create protocol handler (JSON-RPC parsing, message routing)
2. Implement initialization sequence
3. Implement tools/list endpoint
4. Add basic error handling
5. Create test suite for protocol handler
6. Create logging infrastructure

**Deliverables**:
- `src/mcp/protocol-handler.ts` (100+ lines, fully tested)
- `src/mcp/message-types.ts` (type definitions)
- `src/mcp/logger.ts` (logging infrastructure)
- Unit tests for protocol layer (20+ tests)
- Protocol handler integration tests

**Acceptance Criteria**:
- ✓ Initialize request/response works correctly
- ✓ Protocol state properly tracked
- ✓ Error responses formatted correctly
- ✓ Logging works at all levels
- ✓ >80% code coverage

### Phase 2: Service Integration Layer (Week 2)
**Goal**: Service registry and routing infrastructure

**Tasks**:
1. Define IService interface
2. Implement ServiceManager (registry, routing, tool aggregation)
3. Create tool executor
4. Implement JSON Schema validation
5. Add error classification
6. Create tests for service layer

**Deliverables**:
- `src/services/shared/service-interface.ts`
- `src/mcp/service-manager.ts`
- `src/mcp/tool-executor.ts`
- `src/mcp/schema-validator.ts`
- `src/mcp/error-handler.ts`
- Service layer tests (30+ tests)

**Acceptance Criteria**:
- ✓ Services can be registered and discovered
- ✓ Tool names routed to correct service
- ✓ Schema validation works correctly
- ✓ Error handling comprehensive
- ✓ >80% code coverage

### Phase 3: EventLog MCP Service (Week 3)
**Goal**: Wrap Feature 002 EventLog as MCP service

**Tasks**:
1. Create EventLogMCPService class
2. Define EventLog tools (query, list_logs)
3. Translate between MCP and GraphQL formats
4. Add integration with existing GraphQL provider
5. Create service tests
6. Test end-to-end tool execution

**Deliverables**:
- `src/services/eventlog/mcp-service.ts`
- Tool definitions for EventLog
- Integration tests with EventLog provider
- End-to-end MCP tests

**Acceptance Criteria**:
- ✓ EventLog tools discoverable via tools/list
- ✓ Tools executable via tools/call
- ✓ Arguments validated against schema
- ✓ Results formatted as MCP ToolResult
- ✓ Error handling works for all failure modes

### Phase 4: Full Integration & Testing (Week 4)
**Goal**: Complete integration, comprehensive testing, documentation

**Tasks**:
1. Create MCP server entry point
2. Implement stdio startup logic
3. Add comprehensive error scenario tests
4. Create integration tests (protocol + services)
5. Performance testing (tool execution times)
6. Write API documentation
7. Create integration guide for adding services

**Deliverables**:
- `src/mcp/index.ts` (server entry point)
- Comprehensive test suite (50+ tests)
- API documentation (tool definitions, protocol)
- Integration guide for new services
- Example: FileSearch service skeleton

**Acceptance Criteria**:
- ✓ MCP server starts and listens on stdio
- ✓ All protocol features work end-to-end
- ✓ >80% test coverage achieved
- ✓ Tool execution <100ms for typical queries
- ✓ Error messages clear and don't leak info
- ✓ Full audit trail logged

---

## Detailed File Structure

```
src/mcp/
├── index.ts                      # Entry point: MCPServer class
├── protocol-handler.ts           # JSON-RPC protocol and stdio handling
├── message-types.ts              # TypeScript interfaces for protocol
├── service-manager.ts            # Service registry and routing
├── tool-executor.ts              # Tool execution and validation
├── schema-validator.ts           # JSON Schema validation
├── error-handler.ts              # Error codes and handling
├── logger.ts                     # Structured logging
├── utils.ts                      # Utility functions
└── __tests__/
    ├── protocol-handler.test.ts   # Protocol handler tests (20 tests)
    ├── service-manager.test.ts    # Service registry tests (15 tests)
    ├── tool-executor.test.ts      # Tool execution tests (20 tests)
    ├── schema-validator.test.ts   # Validation tests (10 tests)
    ├── error-handling.test.ts     # Error scenario tests (15 tests)
    └── integration.test.ts        # Full integration tests (15 tests)

src/services/
├── shared/
│   └── service-interface.ts       # IService interface
├── eventlog/
│   └── mcp-service.ts            # EventLog MCP wrapper
└── __tests__/
    └── eventlog-mcp.test.ts       # EventLog service tests

src/index.ts                      # Updated: Choose mode (GraphQL or MCP)
```

---

## Key Implementation Details

### 1. Message Parsing Robustness

```typescript
class MessageParser {
  parseMessage(line: string): JSONRPCMessage {
    try {
      const obj = JSON.parse(line);
      
      // Validate JSON-RPC structure
      if (obj.jsonrpc !== "2.0") {
        throw new Error("Invalid jsonrpc version");
      }

      // Either request or response, not both
      if (obj.method && (obj.result || obj.error)) {
        throw new Error("Cannot have both method and result/error");
      }

      return obj as JSONRPCMessage;
    } catch (err) {
      throw new MCPError(-32700, "Parse error", { originalError: err.message });
    }
  }
}
```

### 2. Service Routing

```typescript
async executeTool(name: string, args: unknown): Promise<ToolResult> {
  // Parse tool name: {serviceId}_{operationName}
  const [serviceId, ...operationParts] = name.split("_");
  const operationName = operationParts.join("_");

  if (!serviceId || !operationName) {
    throw new ToolNotFoundError(name);
  }

  const service = this.serviceManager.getService(serviceId);
  if (!service) {
    throw new ToolNotFoundError(name);
  }

  if (!service.enabled) {
    throw new ToolNotFoundError(name); // Service disabled looks like tool not found
  }

  return service.executeTool(operationName, args);
}
```

### 3. EventLog Format Translation

```typescript
private async handleQuery(args: unknown): Promise<ToolResult> {
  // Validate MCP arguments
  const validated = this.validateQueryArgs(args);

  // Translate to GraphQL format
  const graphqlArgs = {
    logName: validated.logName,
    limit: validated.limit,
    offset: validated.offset,
    minLevel: validated.minLevel,
    source: validated.source,
    startTime: validated.startTime ? new Date(validated.startTime) : undefined,
    endTime: validated.endTime ? new Date(validated.endTime) : undefined,
    messageContains: validated.messageContains,
  };

  // Call existing GraphQL provider
  const result = await this.graphqlProvider.query(graphqlArgs);

  // Translate result to MCP format
  return {
    content: [{
      type: "text",
      text: this.formatResult(result)
    }]
  };
}

private formatResult(result: unknown): string {
  return JSON.stringify(result, null, 2);
}
```

---

## Testing Strategy

### Unit Testing

**Protocol Handler** (20 tests):
- Valid JSON parsing
- Invalid JSON error handling
- Message validation (jsonrpc, method, etc.)
- Request/response matching
- Notification handling

**Service Manager** (15 tests):
- Service registration
- Service lookup
- Tool aggregation
- Service enabling/disabling
- Tool routing

**Tool Executor** (20 tests):
- Tool lookup
- Schema validation
- Argument validation
- Tool execution routing
- Result formatting

**Validation** (10 tests):
- Valid schema matches
- Invalid schema matches
- Type checking
- Range validation
- Required field checking

**Error Handling** (15 tests):
- Protocol errors (parse error, method not found, invalid params)
- Tool errors (not found, execution failed)
- Validation errors (with details)
- Error response formatting

### Integration Testing

**Protocol + Services** (15 tests):
- Full initialization sequence
- Tool discovery
- Tool execution (EventLog)
- Error scenarios
- Concurrent tool calls

### Performance Testing

```typescript
describe("Performance", () => {
  it("tool discovery completes in <50ms", async () => {
    const start = Date.now();
    const tools = executor.listTools();
    const elapsed = Date.now() - start;
    expect(elapsed).toBeLessThan(50);
  });

  it("tool execution completes in <100ms", async () => {
    const start = Date.now();
    const result = await executor.executeTool("eventlog_query", {
      logName: "System",
      limit: 10
    });
    const elapsed = Date.now() - start;
    expect(elapsed).toBeLessThan(100);
  });
});
```

### Test Coverage Target

- Protocol Handler: 90%+
- Service Manager: 85%+
- Tool Executor: 85%+
- Validation: 95%+
- Overall: >80%

---

## Error Handling Patterns

### Pattern 1: Validation Error

```typescript
try {
  const validated = schema.validate(args);
} catch (err) {
  // Log full details
  logger.error("Validation failed", {
    toolName: "eventlog_query",
    errors: err.validationErrors,
    args
  });

  // Return MCP error with sanitized message
  throw new InvalidParamsError(
    "Invalid tool arguments",
    err.validationErrors
  );
}
```

### Pattern 2: Service Execution Error

```typescript
try {
  const result = await service.executeTool(operation, args);
  return result;
} catch (err) {
  // Log full error
  logger.error("Tool execution failed", {
    toolName,
    error: err.message,
    stack: err.stack
  });

  // Return generic error to client
  throw new ToolExecutionError(
    "Tool execution failed",
    err
  );
}
```

### Pattern 3: Protocol Error

```typescript
try {
  const message = parser.parseMessage(line);
  handler.dispatch(message);
} catch (err) {
  // Log error with context
  logger.error("Protocol error", {
    line,
    error: err.message
  });

  // Send error response if message had ID
  if (message?.id) {
    sendError(message.id, err);
  }
}
```

---

## Configuration & Extension Points

### Service Registration (Example)

```typescript
// In index.ts or startup code
const mcp = new MCPServer();

// Register EventLog service
const eventlogService = new EventLogMCPService(graphqlProvider);
mcp.registerService(eventlogService);

// Register future services
// const filesearchService = new FileSearchMCPService(...);
// mcp.registerService(filesearchService);

await mcp.start();
```

### Adding New Service (Example)

```typescript
// 1. Create service class implementing IService
class FileSearchMCPService implements IService {
  id = "filesystem";
  name = "File Search Service";
  version = "1.0.0";
  enabled = true;

  getTools(): ToolDefinition[] {
    return [{
      name: "filesystem_search",
      description: "Search files by name or content",
      inputSchema: { /* ... */ }
    }];
  }

  async executeTool(toolName: string, args: unknown): Promise<ToolResult> {
    // Implementation
  }
}

// 2. Register service
const filesearch = new FileSearchMCPService();
mcp.registerService(filesearch);

// That's it! Service is now discoverable and callable via MCP
```

---

## Dependencies & Integration

### Existing Dependencies

- **Feature 001**: MCP Host Bootstrap (infrastructure)
- **Feature 002**: EventLog GraphQL API (wrapped by MCP service)
- **Node.js**: stdio, JSON
- **TypeScript**: Type safety
- **Logger**: Existing pino logger (integrated)

### New Dependencies

- **JSON Schema Validator**: ajv (for input validation)
  - Already available or add to package.json
  - Lightweight and fast

### No New External Dependencies Required

The implementation uses only:
- Node.js built-ins (stdio, JSON, events)
- TypeScript (already in project)
- Existing logger (pino)
- JSON Schema for validation (add if needed: `npm install ajv`)

---

## Open Questions & Decisions

1. **Byte Size Limits**: Should we limit message size to prevent DoS? (proposed: 1MB per message)
2. **Concurrent Requests**: How many concurrent tool calls should we support? (proposed: unlimited, let service limit)
3. **Request Timeout**: Should tool calls have a timeout? (proposed: 30 seconds)
4. **Resource Limits**: Should we cap memory usage per service? (proposed: no, process-level limit instead)
5. **Service Dependencies**: Should services declare dependencies? (proposed: for Phase 2+)
6. **Metrics in Response**: Should every tool response include execution time? (proposed: in metadata)
7. **Protocol Extensions**: Should we plan for custom protocol extensions? (proposed: via capabilities)

---

## Success Metrics

| Metric | Target | How to Measure |
|--------|--------|-----------------|
| Protocol Compliance | 100% | Verify against MCP spec |
| Test Coverage | >80% | Jest coverage report |
| Tool Execution Time | <100ms | Performance tests |
| Tool Discovery Time | <50ms | Performance tests |
| Error Message Quality | 100% | Code review |
| Documentation Completeness | 100% | Doc review checklist |
| Service Extension Ease | High | Try adding FileSearch service |

---

## Timeline Estimate

| Phase | Duration | Start | End |
|-------|----------|-------|-----|
| Phase 1: MCP Protocol Core | 5 days | Day 1 | Day 5 |
| Phase 2: Service Integration | 5 days | Day 6 | Day 10 |
| Phase 3: EventLog Service | 5 days | Day 11 | Day 15 |
| Phase 4: Integration & Testing | 5 days | Day 16 | Day 20 |
| **Total** | **20 days** | | |

---

## Risks & Mitigation

| Risk | Impact | Probability | Mitigation |
|------|--------|------------|-----------|
| MCP protocol complexity | High | Medium | Start simple, add features incrementally |
| EventLog service integration | Medium | Low | GraphQL API well-tested, wrapper is thin |
| Performance issues | Medium | Low | Profile early, test with large result sets |
| Protocol version mismatch | Low | Low | Version negotiation in initialization |
| Service startup failures | High | Low | Graceful degradation, detailed logging |

---

## Document Metadata

- **Plan Version**: 1.0
- **Created**: 2026-02-10
- **Status**: Ready for Implementation
- **Author**: Development Team
- **Related Documents**:
  - `/features/002.1-mcp-protocol-wrapper.spec.md` - Specification
  - `/features/002.1-mcp-protocol-wrapper.tasks.md` - Implementation tasks
  - `/features/002-eventlog-mcp.spec.md` - EventLog specification
- **Approvals Needed**: Technical review, project lead sign-off
- **Next Step**: Break into implementation tasks

